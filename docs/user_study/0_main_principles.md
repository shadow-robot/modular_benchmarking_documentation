# Robotic grasping and manipulation
This page summarizes a crude overview of robotic notions that are essential for grasping and manipulation. Its purpose it to make sure that you can understand some of the technical vocabulary used later.

## Operating a robot
Robots capable of carrying out grasping and/or manipulation tasks are usually composed of at least a robot arm and a robot hand/gripper.
The most elementary action is obviously to move wither the hand or the arm to a desired pose. This can be done either by specifying the cartesian (6D) pose of the tip of the robot or by specifying the values of each joint you want to change. In the latter case, a **controller** will then generate and send the required commands to each joint so the robot's pose matches the expected one. If the 6D pose (position + orientation) of the end effector of the robot is provided then, an additional step will need to be performed to transform the input pose to the corresponding joint states. This is called **Inverse Kinematic** (or IK). The inverse operation (from joint states to pose) is called **Forward Kinematic** or FK). However, before running any of the aforementioned components, a **motion planner** is often used. This component generates a desired trajectory for the arm to reach the desired pose. It becomes important since it includes collisions checking to make sure the robot don't collide with the environment or with itself.

## High level components
The operations described in the previous section can be considered *low*-level. Additional high level components are often required, especially when dealing with semi or autonomous robotic systems. Such components can be compared to the *intelligence* of the robot. For instance, when automatically localizing an object to grasp (through vision), then we want to communicate to the robot that the arm needs to move to this computed location and then to close its hand/gripper.

## Robot Operating System (ROS)
As you probably guessed, programming robots requires fast communication between the different components to ensure a good coordination between each of them. This the role of the Robot Operating System (ROS). It provides the services you would expect from an operating system, including hardware abstraction, low-level device control, implementation of commonly-used functionality, message-passing between processes, and package management. ROS introduces the concept of **URDF** (Unified Robot Description Format) file. This standard file encapsulates hardware-specific information, which downstream services can access. In other words, the URDF file describes the structure of the robot and is a key component to ensure a robot to be integrated to ROS.

## MoveIt!
ROS can be used to operate any kind of robot (e.g. flying, turning, etc.), so it does not embed specific packages for grasping and manipulation. **MoveIt!** is a ROS-compatible framework for manipulation tasks, which is commonly used in the community. This software embeds kinematics libraries, controllers and motion planners for robotic hands/arms. Once a MoveIt! configuration package is defined for a robot, it can be controlled through a C++ / Python API. This stack allows the user to carry out basic operations regarding planning, collision avoidance and motion of the robot, without explicitly implementing them.
